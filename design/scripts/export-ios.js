#!/usr/bin/env node

/**
 * iOS/SwiftUI Token Export
 *
 * Converts W3C DTCG design tokens to SwiftUI-compatible Swift files:
 *   - Colors.swift   (Color extensions with light/dark support)
 *   - Typography.swift (Font definitions)
 *   - Spacing.swift   (CGFloat constants)
 *
 * Usage: node design/scripts/export-ios.js
 * Output: design/generated/ios/
 */

const fs = require('fs');
const path = require('path');
const { loadAllTokens, indexTokenPaths } = require('./validate-tokens');

const OUTPUT_DIR = path.join(__dirname, '..', 'generated', 'ios');

// ---------------------------------------------------------------------------
// Hex color to SwiftUI Color components (0-1 range)
// ---------------------------------------------------------------------------

function hexToRGBComponents(hex) {
  hex = hex.replace('#', '');
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length === 8) hex = hex.slice(0, 6);

  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;

  return { r: round(r), g: round(g), b: round(b) };
}

function round(n) {
  return Math.round(n * 1000) / 1000;
}

// ---------------------------------------------------------------------------
// Resolve token references to final hex values
// ---------------------------------------------------------------------------

function resolveValue(value, tokenIndex, seen) {
  seen = seen || new Set();
  if (typeof value === 'string') {
    const refMatch = value.match(/^\{([^}]+)\}$/);
    if (refMatch) {
      const refPath = refMatch[1];
      if (seen.has(refPath)) return value;
      seen.add(refPath);
      const refToken = tokenIndex[refPath];
      if (refToken) return resolveValue(refToken.$value, tokenIndex, seen);
    }
    return value;
  }
  return value;
}

// ---------------------------------------------------------------------------
// Swift name helpers
// ---------------------------------------------------------------------------

function swiftName(tokenPath) {
  // color.semantic.brand.primary -> brandPrimary
  const parts = tokenPath.split('.');
  // Skip category prefixes
  const meaningful = parts.filter(p => !['color', 'semantic', 'primitive', 'dark'].includes(p));
  return meaningful
    .map((p, i) => i === 0 ? camelCase(p) : capitalize(camelCase(p)))
    .join('');
}

function camelCase(s) {
  return s.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
}

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

// ---------------------------------------------------------------------------
// Generate Colors.swift
// ---------------------------------------------------------------------------

function generateColors(tokenIndex) {
  const lines = [
    '// Generated by design/scripts/export-ios.js — DO NOT EDIT',
    '// Source: design/tokens/*.json (W3C DTCG format)',
    '',
    'import SwiftUI',
    '',
    '// MARK: - Semantic Colors',
    '',
    'extension Color {',
  ];

  // Collect semantic light and dark tokens
  const semanticLight = {};
  const semanticDark = {};

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'color') continue;

    if (tokenPath.startsWith('color.semantic.')) {
      const resolved = resolveValue(token.$value, tokenIndex);
      if (typeof resolved === 'string' && resolved.startsWith('#')) {
        semanticLight[tokenPath] = resolved;
      }
    } else if (tokenPath.startsWith('color.dark.')) {
      const resolved = resolveValue(token.$value, tokenIndex);
      if (typeof resolved === 'string' && resolved.startsWith('#')) {
        const semanticPath = tokenPath.replace('color.dark.', 'color.semantic.');
        semanticDark[semanticPath] = resolved;
      }
    }
  }

  // Generate semantic color properties with light/dark adaptive support
  for (const [tokenPath, lightHex] of Object.entries(semanticLight)) {
    const name = swiftName(tokenPath);
    const darkHex = semanticDark[tokenPath];

    const light = hexToRGBComponents(lightHex);

    if (darkHex) {
      const dark = hexToRGBComponents(darkHex);
      lines.push(`    static let ${name} = Color(light: .init(red: ${light.r}, green: ${light.g}, blue: ${light.b}), dark: .init(red: ${dark.r}, green: ${dark.g}, blue: ${dark.b}))`);
    } else {
      lines.push(`    static let ${name} = Color(red: ${light.r}, green: ${light.g}, blue: ${light.b})`);
    }
  }

  lines.push('}');
  lines.push('');

  // Primitive colors as a nested enum
  lines.push('// MARK: - Primitive Colors');
  lines.push('');
  lines.push('extension Color {');
  lines.push('    enum Primitive {');

  const primitiveGroups = {};
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'color') continue;
    if (!tokenPath.startsWith('color.primitive.')) continue;

    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved !== 'string' || !resolved.startsWith('#')) continue;

    const parts = tokenPath.replace('color.primitive.', '').split('.');
    if (parts.length === 2) {
      if (!primitiveGroups[parts[0]]) primitiveGroups[parts[0]] = {};
      primitiveGroups[parts[0]][parts[1]] = resolved;
    } else if (parts.length === 1) {
      primitiveGroups[parts[0]] = resolved;
    }
  }

  for (const [groupName, shades] of Object.entries(primitiveGroups)) {
    if (typeof shades === 'string') {
      const { r, g, b } = hexToRGBComponents(shades);
      lines.push(`        static let ${camelCase(groupName)} = Color(red: ${r}, green: ${g}, blue: ${b})`);
    } else {
      lines.push(`        enum ${capitalize(camelCase(groupName))} {`);
      for (const [shade, hex] of Object.entries(shades)) {
        const { r, g, b } = hexToRGBComponents(hex);
        lines.push(`            static let _${shade} = Color(red: ${r}, green: ${g}, blue: ${b})`);
      }
      lines.push('        }');
    }
  }

  lines.push('    }');
  lines.push('}');
  lines.push('');

  // Color init helper for light/dark adaptive
  lines.push('// MARK: - Light/Dark Adaptive Helper');
  lines.push('');
  lines.push('private extension Color {');
  lines.push('    init(light: Color, dark: Color) {');
  lines.push('        self.init(UIColor { traitCollection in');
  lines.push('            traitCollection.userInterfaceStyle == .dark ? UIColor(dark) : UIColor(light)');
  lines.push('        })');
  lines.push('    }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Generate Typography.swift
// ---------------------------------------------------------------------------

function generateTypography(tokenIndex) {
  const lines = [
    '// Generated by design/scripts/export-ios.js — DO NOT EDIT',
    '// Source: design/tokens/*.json (W3C DTCG format)',
    '',
    'import SwiftUI',
    '',
    '// MARK: - Typography',
    '',
    'struct AppTypography {',
  ];

  // Font sizes
  lines.push('    // MARK: Font Sizes');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.size.')) continue;
    const name = tokenPath.replace('font.size.', '');
    const value = token.$value;
    // Convert rem to pt (1rem = 16pt base)
    const pt = remToPt(value);
    lines.push(`    static let fontSize${capitalize(camelCase(name))}: CGFloat = ${pt}`);
  }

  lines.push('');

  // Font weights
  lines.push('    // MARK: Font Weights');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.weight.')) continue;
    const name = tokenPath.replace('font.weight.', '');
    const weight = mapFontWeight(token.$value);
    lines.push(`    static let fontWeight${capitalize(camelCase(name))}: Font.Weight = .${weight}`);
  }

  lines.push('');

  // Line heights
  lines.push('    // MARK: Line Heights');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.lineHeight.')) continue;
    const name = tokenPath.replace('font.lineHeight.', '');
    lines.push(`    static let lineHeight${capitalize(camelCase(name))}: CGFloat = ${token.$value}`);
  }

  lines.push('');

  // Letter spacing
  lines.push('    // MARK: Letter Spacing');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.letterSpacing.')) continue;
    const name = tokenPath.replace('font.letterSpacing.', '');
    const em = parseFloat(token.$value);
    // Convert em to pt at 16pt base
    const pt = round(em * 16);
    lines.push(`    static let letterSpacing${capitalize(camelCase(name))}: CGFloat = ${pt}`);
  }

  lines.push('}');
  lines.push('');

  // Composite typography presets from semantic tokens
  lines.push('// MARK: - Typography Presets');
  lines.push('');
  lines.push('extension Font {');

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'typography') continue;

    const parts = tokenPath.split('.');
    const name = parts.slice(1).map((p, i) => i === 0 ? camelCase(p) : capitalize(camelCase(p))).join('');

    const val = token.$value;
    const size = resolveValue(val.fontSize, tokenIndex);
    const weight = resolveValue(val.fontWeight, tokenIndex);

    const pt = remToPt(size);
    const swiftWeight = mapFontWeight(weight);

    lines.push(`    static let ${name} = Font.system(size: ${pt}, weight: .${swiftWeight})`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Generate Spacing.swift
// ---------------------------------------------------------------------------

function generateSpacing(tokenIndex) {
  const lines = [
    '// Generated by design/scripts/export-ios.js — DO NOT EDIT',
    '// Source: design/tokens/*.json (W3C DTCG format)',
    '',
    'import SwiftUI',
    '',
    '// MARK: - Spacing',
    '',
    'struct AppSpacing {',
  ];

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('spacing.')) continue;
    const name = tokenPath.replace('spacing.', '').replace('.', '_');
    const safeName = /^\d/.test(name) ? `sp${name}` : camelCase(name);
    const pt = remToPt(token.$value);
    lines.push(`    static let ${safeName}: CGFloat = ${pt}`);
  }

  lines.push('}');
  lines.push('');

  // Border radius
  lines.push('// MARK: - Border Radius');
  lines.push('');
  lines.push('struct AppRadius {');

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('radius.')) continue;
    const name = tokenPath.replace('radius.', '');
    const pt = remToPt(token.$value);
    lines.push(`    static let ${camelCase(name)}: CGFloat = ${pt}`);
  }

  lines.push('}');
  lines.push('');

  // Shadows
  lines.push('// MARK: - Shadows');
  lines.push('');
  lines.push('struct AppShadow {');
  lines.push('    let color: Color');
  lines.push('    let radius: CGFloat');
  lines.push('    let x: CGFloat');
  lines.push('    let y: CGFloat');
  lines.push('}');
  lines.push('');
  lines.push('extension AppShadow {');

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'shadow') continue;
    const name = tokenPath.replace('shadow.', '');

    const shadow = Array.isArray(token.$value) ? token.$value[0] : token.$value;
    const blur = parseFloat(shadow.blur) || 0;
    const offsetY = parseFloat(shadow.offsetY) || 0;
    const offsetX = parseFloat(shadow.offsetX.replace('inset ', '')) || 0;

    lines.push(`    static let ${camelCase(name)} = AppShadow(color: .black.opacity(0.1), radius: ${blur}, x: ${offsetX}, y: ${offsetY})`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function remToPt(value) {
  if (typeof value !== 'string') return 0;
  if (value === '0') return 0;
  if (value.endsWith('px')) return parseFloat(value);
  if (value.endsWith('rem')) return round(parseFloat(value) * 16);
  return parseFloat(value) || 0;
}

function mapFontWeight(value) {
  const map = {
    '100': 'ultraLight',
    '200': 'thin',
    '300': 'light',
    '400': 'regular',
    '500': 'medium',
    '600': 'semibold',
    '700': 'bold',
    '800': 'heavy',
    '900': 'black',
  };
  return map[String(value)] || 'regular';
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function generate() {
  const { merged } = loadAllTokens();
  const tokenIndex = indexTokenPaths(merged);

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  const colors = generateColors(tokenIndex);
  const typography = generateTypography(tokenIndex);
  const spacing = generateSpacing(tokenIndex);

  const colorsPath = path.join(OUTPUT_DIR, 'Colors.swift');
  const typographyPath = path.join(OUTPUT_DIR, 'Typography.swift');
  const spacingPath = path.join(OUTPUT_DIR, 'Spacing.swift');

  fs.writeFileSync(colorsPath, colors);
  fs.writeFileSync(typographyPath, typography);
  fs.writeFileSync(spacingPath, spacing);

  return {
    outputDir: OUTPUT_DIR,
    files: [colorsPath, typographyPath, spacingPath],
    colors,
    typography,
    spacing,
  };
}

if (require.main === module) {
  const result = generate();
  console.log(`Generated iOS files in: ${result.outputDir}`);
  result.files.forEach(f => console.log(`  ${path.basename(f)}`));
}

module.exports = { generate, hexToRGBComponents, remToPt };
