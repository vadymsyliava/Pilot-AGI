#!/usr/bin/env node

/**
 * Android Token Export
 *
 * Converts W3C DTCG design tokens to Android XML resource files:
 *   - colors.xml       (Color resources — light mode)
 *   - colors-night.xml (Color resources — dark mode override)
 *   - dimens.xml       (Spacing, radius, font sizes)
 *   - type.xml         (Font family, weight, z-index, durations)
 *
 * Usage: node design/scripts/export-android.js
 * Output: design/generated/android/
 */

const fs = require('fs');
const path = require('path');
const { loadAllTokens, indexTokenPaths } = require('./validate-tokens');

const OUTPUT_DIR = path.join(__dirname, '..', 'generated', 'android');

// ---------------------------------------------------------------------------
// Resolve token references to final values
// ---------------------------------------------------------------------------

function resolveValue(value, tokenIndex, seen) {
  seen = seen || new Set();
  if (typeof value === 'string') {
    const refMatch = value.match(/^\{([^}]+)\}$/);
    if (refMatch) {
      const refPath = refMatch[1];
      if (seen.has(refPath)) return value;
      seen.add(refPath);
      const refToken = tokenIndex[refPath];
      if (refToken) return resolveValue(refToken.$value, tokenIndex, seen);
    }
    return value;
  }
  return value;
}

// ---------------------------------------------------------------------------
// Android resource name helpers
// ---------------------------------------------------------------------------

function androidName(tokenPath) {
  return tokenPath
    .replace(/\./g, '_')
    .replace(/\$/g, '')
    .replace(/-/g, '_')
    .toLowerCase();
}

function escapeXml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// ---------------------------------------------------------------------------
// Rem to dp/sp conversion (1rem = 16dp base)
// ---------------------------------------------------------------------------

function remToDp(value) {
  if (typeof value !== 'string') return '0dp';
  if (value === '0') return '0dp';
  if (value.endsWith('px')) return Math.round(parseFloat(value)) + 'dp';
  if (value.endsWith('rem')) return Math.round(parseFloat(value) * 16) + 'dp';
  const num = parseFloat(value);
  if (!isNaN(num)) return Math.round(num) + 'dp';
  return '0dp';
}

function remToSp(value) {
  if (typeof value !== 'string') return '0sp';
  if (value === '0') return '0sp';
  if (value.endsWith('px')) return Math.round(parseFloat(value)) + 'sp';
  if (value.endsWith('rem')) return Math.round(parseFloat(value) * 16) + 'sp';
  const num = parseFloat(value);
  if (!isNaN(num)) return Math.round(num) + 'sp';
  return '0sp';
}

// ---------------------------------------------------------------------------
// Generate colors.xml
// ---------------------------------------------------------------------------

function generateColors(tokenIndex) {
  const lines = [
    '<?xml version="1.0" encoding="utf-8"?>',
    '<!-- Generated by design/scripts/export-android.js — DO NOT EDIT -->',
    '<!-- Source: design/tokens/*.json (W3C DTCG format) -->',
    '<resources>',
  ];

  // Primitive colors
  lines.push('    <!-- Primitive Colors -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'color') continue;
    if (!tokenPath.startsWith('color.primitive.')) continue;

    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved !== 'string' || !resolved.startsWith('#')) continue;

    const name = androidName(tokenPath);
    lines.push(`    <color name="${name}">${resolved.toUpperCase()}</color>`);
  }

  lines.push('');

  // Semantic colors (light mode)
  lines.push('    <!-- Semantic Colors (Light) -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'color') continue;
    if (!tokenPath.startsWith('color.semantic.')) continue;

    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved !== 'string' || !resolved.startsWith('#')) continue;

    const name = androidName(tokenPath);
    lines.push(`    <color name="${name}">${resolved.toUpperCase()}</color>`);
  }

  lines.push('</resources>');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Generate night colors.xml (dark mode override)
// ---------------------------------------------------------------------------

function generateNightColors(tokenIndex) {
  const lines = [
    '<?xml version="1.0" encoding="utf-8"?>',
    '<!-- Generated by design/scripts/export-android.js — DO NOT EDIT -->',
    '<!-- Dark mode overrides: place in values-night/ -->',
    '<resources>',
  ];

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'color') continue;
    if (!tokenPath.startsWith('color.dark.')) continue;

    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved !== 'string' || !resolved.startsWith('#')) continue;

    const semanticName = androidName(tokenPath.replace('color.dark.', 'color.semantic.'));
    lines.push(`    <color name="${semanticName}">${resolved.toUpperCase()}</color>`);
  }

  lines.push('</resources>');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Generate dimens.xml
// ---------------------------------------------------------------------------

function generateDimens(tokenIndex) {
  const lines = [
    '<?xml version="1.0" encoding="utf-8"?>',
    '<!-- Generated by design/scripts/export-android.js — DO NOT EDIT -->',
    '<!-- Source: design/tokens/*.json (W3C DTCG format) -->',
    '<resources>',
  ];

  // Spacing
  lines.push('    <!-- Spacing -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('spacing.')) continue;
    const name = androidName(tokenPath);
    const dp = remToDp(token.$value);
    lines.push(`    <dimen name="${name}">${dp}</dimen>`);
  }

  lines.push('');

  // Border radius
  lines.push('    <!-- Border Radius -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('radius.')) continue;
    const name = androidName(tokenPath);
    const dp = remToDp(token.$value);
    lines.push(`    <dimen name="${name}">${dp}</dimen>`);
  }

  lines.push('');

  // Font sizes (use sp for text)
  lines.push('    <!-- Font Sizes -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.size.')) continue;
    const name = androidName(tokenPath);
    const sp = remToSp(token.$value);
    lines.push(`    <dimen name="${name}">${sp}</dimen>`);
  }

  lines.push('');

  // Breakpoints (as dp for reference)
  lines.push('    <!-- Breakpoints -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('breakpoint.')) continue;
    const name = androidName(tokenPath);
    const dp = remToDp(token.$value);
    lines.push(`    <dimen name="${name}">${dp}</dimen>`);
  }

  lines.push('</resources>');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Generate type.xml
// ---------------------------------------------------------------------------

function generateType(tokenIndex) {
  const lines = [
    '<?xml version="1.0" encoding="utf-8"?>',
    '<!-- Generated by design/scripts/export-android.js — DO NOT EDIT -->',
    '<!-- Source: design/tokens/*.json (W3C DTCG format) -->',
    '<resources>',
  ];

  // Font families as string resources
  lines.push('    <!-- Font Families -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'fontFamily') continue;
    const name = androidName(tokenPath);
    const families = Array.isArray(token.$value) ? token.$value : [token.$value];
    lines.push(`    <string name="${name}" translatable="false">${escapeXml(families.join(', '))}</string>`);
  }

  lines.push('');

  // Font weights as integer resources
  lines.push('    <!-- Font Weights -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'fontWeight') continue;
    const name = androidName(tokenPath);
    lines.push(`    <integer name="${name}">${token.$value}</integer>`);
  }

  lines.push('');

  // Line heights as item resources (multipliers)
  lines.push('    <!-- Line Heights (multiplier) -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('font.lineHeight.')) continue;
    const name = androidName(tokenPath);
    lines.push(`    <item name="${name}" format="float" type="dimen">${token.$value}</item>`);
  }

  lines.push('');

  // Z-index as integers
  lines.push('    <!-- Z-Index (elevation reference) -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('zIndex.')) continue;
    const name = androidName(tokenPath);
    lines.push(`    <integer name="${name}">${token.$value}</integer>`);
  }

  lines.push('');

  // Durations
  lines.push('    <!-- Animation Durations -->');
  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (token.$type !== 'duration') continue;
    const name = androidName(tokenPath);
    const ms = parseInt(token.$value) || 0;
    lines.push(`    <integer name="${name}">${ms}</integer>`);
  }

  lines.push('</resources>');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function generate() {
  const { merged } = loadAllTokens();
  const tokenIndex = indexTokenPaths(merged);

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  const colors = generateColors(tokenIndex);
  const nightColors = generateNightColors(tokenIndex);
  const dimens = generateDimens(tokenIndex);
  const type = generateType(tokenIndex);

  const colorsPath = path.join(OUTPUT_DIR, 'colors.xml');
  const nightColorsPath = path.join(OUTPUT_DIR, 'colors-night.xml');
  const dimensPath = path.join(OUTPUT_DIR, 'dimens.xml');
  const typePath = path.join(OUTPUT_DIR, 'type.xml');

  fs.writeFileSync(colorsPath, colors);
  fs.writeFileSync(nightColorsPath, nightColors);
  fs.writeFileSync(dimensPath, dimens);
  fs.writeFileSync(typePath, type);

  return {
    outputDir: OUTPUT_DIR,
    files: [colorsPath, nightColorsPath, dimensPath, typePath],
    colors,
    nightColors,
    dimens,
    type,
  };
}

if (require.main === module) {
  const result = generate();
  console.log(`Generated Android files in: ${result.outputDir}`);
  result.files.forEach(f => console.log(`  ${path.basename(f)}`));
}

module.exports = { generate, remToDp, remToSp };
