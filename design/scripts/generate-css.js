#!/usr/bin/env node

/**
 * CSS Custom Properties Generator
 *
 * Converts design tokens to CSS custom properties.
 * Colors are output in HSL format for shadcn/ui compatibility.
 *
 * Usage: node design/scripts/generate-css.js
 * Output: design/generated/tokens.css
 */

const fs = require('fs');
const path = require('path');
const { loadAllTokens, indexTokenPaths, extractRefs } = require('./validate-tokens');

const OUTPUT_PATH = path.join(__dirname, '..', 'generated', 'tokens.css');

// ---------------------------------------------------------------------------
// Color conversion: hex -> HSL (shadcn/ui uses "H S% L%" without commas)
// ---------------------------------------------------------------------------

function hexToHSL(hex) {
  hex = hex.replace('#', '');

  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }

  // Handle 8-char hex (with alpha) — strip alpha for HSL
  if (hex.length === 8) {
    hex = hex.slice(0, 6);
  }

  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;

  if (max === min) {
    return `0 0% ${Math.round(l * 100)}%`;
  }

  const d = max - min;
  const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

  let h;
  if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
  else if (max === g) h = ((b - r) / d + 2) / 6;
  else h = ((r - g) / d + 4) / 6;

  return `${Math.round(h * 360)} ${Math.round(s * 100)}% ${Math.round(l * 100)}%`;
}

// ---------------------------------------------------------------------------
// Resolve token references to final values
// ---------------------------------------------------------------------------

function resolveValue(value, tokenIndex, seen) {
  seen = seen || new Set();

  if (typeof value === 'string') {
    const refMatch = value.match(/^\{([^}]+)\}$/);
    if (refMatch) {
      const refPath = refMatch[1];
      if (seen.has(refPath)) return value; // circular, return as-is
      seen.add(refPath);
      const refToken = tokenIndex[refPath];
      if (refToken) {
        return resolveValue(refToken.$value, tokenIndex, seen);
      }
    }
    return value;
  }

  return value;
}

// ---------------------------------------------------------------------------
// Generate CSS variable name from token path
// ---------------------------------------------------------------------------

function tokenPathToVar(tokenPath) {
  return '--' + tokenPath
    .replace(/\./g, '-')
    .replace(/\$/g, '')
    .toLowerCase();
}

// ---------------------------------------------------------------------------
// Shadow value to CSS string
// ---------------------------------------------------------------------------

function shadowToCSS(shadow) {
  if (Array.isArray(shadow)) {
    return shadow.map(s => shadowPartToCSS(s)).join(', ');
  }
  return shadowPartToCSS(shadow);
}

function shadowPartToCSS(s) {
  return `${s.offsetX} ${s.offsetY} ${s.blur} ${s.spread} ${s.color}`;
}

// ---------------------------------------------------------------------------
// Cubic bezier to CSS string
// ---------------------------------------------------------------------------

function cubicBezierToCSS(value) {
  if (Array.isArray(value)) {
    return `cubic-bezier(${value.join(', ')})`;
  }
  return String(value);
}

// ---------------------------------------------------------------------------
// Generate CSS for a set of color tokens (light or dark mode)
// ---------------------------------------------------------------------------

function generateColorVars(colorTokens, tokenIndex) {
  const lines = [];

  for (const [tokenPath, token] of Object.entries(colorTokens)) {
    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved === 'string' && resolved.startsWith('#')) {
      const varName = tokenPathToVar(tokenPath);
      lines.push(`  ${varName}: ${hexToHSL(resolved)};`);
    }
  }

  return lines;
}

// ---------------------------------------------------------------------------
// Main generation
// ---------------------------------------------------------------------------

function generate() {
  const { merged } = loadAllTokens();
  const tokenIndex = indexTokenPaths(merged);

  const sections = [];

  // Header
  sections.push('/* Generated by design/scripts/generate-css.js — DO NOT EDIT */');
  sections.push('/* Source: design/tokens/*.json (W3C DTCG format) */');
  sections.push('');

  // ── :root (light mode) ──
  const rootVars = [];

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    const resolved = resolveValue(token.$value, tokenIndex);

    // Skip dark mode tokens (handled separately)
    if (tokenPath.startsWith('color.dark.')) continue;

    // Skip composite typography tokens (not single CSS vars)
    if (token.$type === 'typography') continue;

    const varName = tokenPathToVar(tokenPath);

    if (token.$type === 'color') {
      if (typeof resolved === 'string' && resolved.startsWith('#')) {
        rootVars.push(`  ${varName}: ${hexToHSL(resolved)};`);
      }
    } else if (token.$type === 'shadow') {
      rootVars.push(`  ${varName}: ${shadowToCSS(resolved)};`);
    } else if (token.$type === 'cubicBezier') {
      rootVars.push(`  ${varName}: ${cubicBezierToCSS(resolved)};`);
    } else if (token.$type === 'fontFamily') {
      const val = Array.isArray(resolved) ? resolved.join(', ') : resolved;
      rootVars.push(`  ${varName}: ${val};`);
    } else {
      rootVars.push(`  ${varName}: ${resolved};`);
    }
  }

  // shadcn/ui compatibility aliases
  rootVars.push('');
  rootVars.push('  /* shadcn/ui compatibility aliases */');
  rootVars.push('  --background: var(--color-semantic-background-default);');
  rootVars.push('  --foreground: var(--color-semantic-foreground-default);');
  rootVars.push('  --primary: var(--color-semantic-brand-primary);');
  rootVars.push('  --primary-foreground: var(--color-semantic-foreground-inverse);');
  rootVars.push('  --secondary: var(--color-semantic-background-muted);');
  rootVars.push('  --secondary-foreground: var(--color-semantic-foreground-default);');
  rootVars.push('  --muted: var(--color-semantic-background-muted);');
  rootVars.push('  --muted-foreground: var(--color-semantic-foreground-muted);');
  rootVars.push('  --accent: var(--color-semantic-background-subtle);');
  rootVars.push('  --accent-foreground: var(--color-semantic-foreground-default);');
  rootVars.push('  --destructive: var(--color-semantic-state-error);');
  rootVars.push('  --destructive-foreground: var(--color-semantic-foreground-inverse);');
  rootVars.push('  --border: var(--color-semantic-border-default);');
  rootVars.push('  --input: var(--color-semantic-border-default);');
  rootVars.push('  --ring: var(--color-semantic-ring-default);');
  rootVars.push('  --radius: var(--radius-lg);');

  sections.push(':root {');
  sections.push(rootVars.join('\n'));
  sections.push('}');
  sections.push('');

  // ── .dark (dark mode) ──
  const darkVars = [];

  for (const [tokenPath, token] of Object.entries(tokenIndex)) {
    if (!tokenPath.startsWith('color.dark.')) continue;

    const resolved = resolveValue(token.$value, tokenIndex);
    if (typeof resolved !== 'string' || !resolved.startsWith('#')) continue;

    // Map dark token path to its semantic equivalent var name
    const semanticPath = tokenPath.replace('color.dark.', 'color.semantic.');
    const varName = tokenPathToVar(semanticPath);
    darkVars.push(`  ${varName}: ${hexToHSL(resolved)};`);
  }

  if (darkVars.length > 0) {
    sections.push('.dark {');
    sections.push(darkVars.join('\n'));
    sections.push('}');
    sections.push('');
  }

  const css = sections.join('\n') + '\n';

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_PATH, css);
  return { outputPath: OUTPUT_PATH, varCount: rootVars.length + darkVars.length, css };
}

// CLI entry point
if (require.main === module) {
  const result = generate();
  console.log(`Generated: ${result.outputPath}`);
  console.log(`CSS variables: ${result.varCount}`);
}

module.exports = { generate, hexToHSL };
